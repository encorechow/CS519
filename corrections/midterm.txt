Question 4 (b). What's this code's time complexity?
    Correction: Time complexity of this code is O(klogk + nlog(n+k))

Question 4 (c). Assume k >> n, can you make it faster? Describe an obvious method and analyze time complexity.
    Correction: Instead of trypush the first element in the list, we can just pick up initial k pairs and store them into an a list, then heapify them. The rest of algorithm remain the same. the total time complexity reduce to O(k + nlog(n+k)) since heapify only cost O(k).

Question 4 (d). Describe another method to make it even faster (still k >> n); analyze time.
    Correction: Since k >> n, initially we picked up k pairs and stored them into a list. After this we can do a quick-select to find the nth smallest element in the initial list. This will cost O(k) time. And then we heapify the pairs that are smaller than or equal to nth pair and pop the pairs in order. So the heap size will be at most 2*n. The total time complexity will be O(k + nlogn).

Question 5. A memorized recursive implementation
    Correction: I should pass the cache into recursive function call: cache[n] = fib(n-1, cache) + fib(n-1, cache)



Question 6 (e):
    Correction: The subproblem is the minimum types of coins that are used for value v with only 0 to idx coins available is either we take the coin at idx position with c times or we don't. For the first case, we decrease the value v: v-c*(value of coin) and find out the minimum types of coins that are used for value v-c*(value of coin) without the coin at idx position.

Question 6(f):
    Correction: Suppose dp[v, idx] stores the minimum types of coins that are used for value v with only 0 to idx coins available.
        dp[v, idx] = min(dp[v-c*coin, idx-1], dp[v, idx-1]) for c in v // coin


Question 6 (g).
    Correction: space complexity is O(VN) suppose value is V and number of coins is N. Time complexity is O(VM) where M is the sum of maximum count that each coin can be taken.

